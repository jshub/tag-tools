<% set_title "Date and URI utilities < Libraries" %>

<% content_for :javascripts do %>  
  <!-- Nothin required, just testing jQuery libraries here -->
<% end %>

<% content_for :intro do %>
<p>This file tests the date and URI parsing utilities provided by jQuery.</p>
<% end %>

<script language="javascript" type="text/javascript">
/* <![CDATA[  // */

  suite.add(new Y.Test.Case({
    name: "ISO8601 date parsing",
    
    _should: {
      ignore: {
        "test to date from ISO8601 string with timezone info": true
      },
      fail: {
        "test to 5 digit year date from ISO8601 string": true
      }
    },
    
    "test normalize ISO8601 date from string": function() {
    
      // datetime string with secs and timezone (no normalization needed)
      var src = "2005-06-29T08:05:33-0700";
      var normalized = $.normalizeISO8601(src);
      var human = "2005-06-29T08:05:33-0700";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // datetime string with secs, fractional secs and timezone (no normalization needed)
      var src = "2005-06-29T08:05:33.45-0700";
      var normalized = $.normalizeISO8601(src);
      var human = "2005-06-29T08:05:33.45-0700";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // datetime string with secs and alt timezone format
      src = "2005-06-29T08:05:33-07:00";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29T08:05:33-0700";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");
      
      // datetime string with secs and no timezone info
      src = "2005-06-29T08:05:33";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29T08:05:33";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // datetime string without secs and no timezone info
      src = "2005-06-29T08:05";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29T08:05:00";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // datetime string without mins, secs and no timezone info
      src = "2005-06-29T08";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29T08:00:00";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // date string with trailing T misimplementation
      src = "2005-06-29T";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // date string (no normalization needed)
      src = "2005-06-29";
      normalized = $.normalizeISO8601(src);
      human = "2005-06-29";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

    },

    "test normalize ISO8601 date protected from bad input": function() {

      // handles all zeros?
      src = "0000-00-00T00:00:00-0000";
      normalized = $.normalizeISO8601(src);
      human = "0000-00-00T00:00:00-0000";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");
      src = "0000-00-00";
      normalized = $.normalizeISO8601(src);
      human = "0000-00-00";
      Y.Assert.areSame(human, normalized, "ISO8601 date not normalized correctly");

      // Ambiguous 2 digit date string
      src = "05-06-29";
      normalized = $.normalizeISO8601(src);
      Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // Time only string
      src = "T18:46:39";
      normalized = $.normalizeISO8601(src);
      Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // garbage string should not be parsed
      var src = "blah 22 99 :12";
      normalized = $.normalizeISO8601(src);
      Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // empty string should not be parsed
      src = "";
      normalized = $.normalizeISO8601(src);
      Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // TODO other things we could protect against in the library
      
      // undeclared var should not be parsed
      //var varundeclared;
      //normalized = $.normalizeISO8601(varundeclared);
      //Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // undeclared var should not be parsed
      //var varundefined = undefined;
      //normalized = $.normalizeISO8601(varundefined);
      //Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // undeclared var should not be parsed
      //var varfalse = false;
      //normalized = $.normalizeISO8601(varfalse);
      //Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

      // undeclared var should not be parsed
      //var varnull = null;
      //normalized = $.normalizeISO8601(varnull);
      //Y.Assert.isUndefined(normalized, "No normalization possible should return undefined");

    },

      /* 
        Tests taken from dojo.date.*, which is actively maintained, but we cannot use the 
        hardcoded values to test against due to the timezone differences between local and 
        remote (Litmus) browsers. 
      */

    "test to date from ISO8601 string with timezone info": function() {
      var rfc = "2005-06-29T08:05:00-07:00";
      var date = $.dateFromISO8601(rfc);
      var human = "Wed, 29 Jun 2005 08:05:00 GMT-0700";
      Y.Assert.areSame(Date.parse(human), Date.parse(date), 'ISO8601 dates are not the same after parsing');
      // this may not be testable due to variants in the toString text
      Y.Assert.areSame(human, date.toUTCString(), 'Date.toUTCString formats do not match');
    },

    "test to date from ISO8601 string": function() {
    
      // No TZ info means local time
      var rfc = "2005-06-29T08:05:00";
      var date = $.dateFromISO8601(rfc);
      var human = "Wed, 29 Jun 2005 08:05:00";
      // In our implementation a flag is set for convienience if a time was set
      Y.Assert.isTrue(date.time, 'Date should have a time flag');
      Y.Assert.areSame(Date.parse(human), Date.parse(date), 'ISO8601 dates are not the same after parsing');
      
      // handle a leap year date
      rfc = "2004-02-29T01:23:45";
      date = $.dateFromISO8601(rfc);
      human = "Sun, 29 Feb 2004 01:23:45";
      h = new Date(human);
      Y.Assert.isTrue(date.time, 'Date should have a time flag');
      Y.Assert.areSame(h.getUTCDate(), date.getUTCDate(), 'getUTCDate is not correct after parsing');
      Y.Assert.areSame(h.getUTCHours(), date.getUTCHours(), 'getUTCHours is not correct after parsing'); 
      Y.Assert.areSame(h.getUTCMinutes(), date.getUTCMinutes(), 'getUTCMinutes is not correct after parsing');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');
      Y.Assert.areSame(h.getHours(), date.getHours(), 'getHours is not correct after parsing');
      
      rfc = "2004-02-29";
      date = $.dateFromISO8601(rfc);
      human = "Sun, 29 Feb 2004";
      h = new Date(human);
      Y.Assert.isFalse(date.time, 'Date should not have a time flag');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');

    },
    
    "test infer defaults from partial ISO8601 string": function() {
      
      // create date even when build-in Date object cannot
      rfc = "2004-01";
      date = $.dateFromISO8601(rfc);
      human = "Thur, 01 Jan 2004";
      h = new Date(human);
      Y.Assert.isFalse(date.time, 'Date should not have a time flag');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');

    },
    
    "test extreme dates from ISO8601 string": function() {
      
      // ancient date
      rfc = "0101-01-01";
      date = $.dateFromISO8601(rfc);
      human = "Sat, 01 Jan 0101";
      h = new Date(human);
      Y.Assert.isFalse(date.time, 'Date should not have a time flag');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');

      // future date
      rfc = "9999-12-31";
      date = $.dateFromISO8601(rfc);
      human = "Fri, 31 Dec 9999";
      h = new Date(human);
      Y.Assert.isFalse(date.time, 'Date should not have a time flag');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');

    },
    
    "test to 5 digit year date from ISO8601 string": function() {

      // 5 digit year future date (which we don't support yet)
      rfc = "10000-01-01";
      date = $.dateFromISO8601(rfc);
      human = "Sat, 01 Jan 10000";
      h = new Date(human);
      Y.Assert.isFalse(date.time, 'Date should not have a time flag');
      Y.Assert.areSame(h.getFullYear(), date.getFullYear(), 'getFullYear is not correct after parsing');
      Y.Assert.areSame(h.getMonth(), date.getMonth(), 'getMonth is not correct after parsing');
      Y.Assert.areSame(h.getDate(), date.getDate(), 'getDate is not correct after parsing');
          
    },
    
    "test to ISO8601 from date": function() {
    
      var date = new Date(2005, 5, 29, 8, 5, 0);
      var rfc = $.iso8601FromDate(date);
      //truncate for comparison
      Y.Assert.areSame("200506", rfc.substring(0, 6));
      // use punctuation
      rfc = $.iso8601FromDate(date, true);
      //truncate for comparison
      Y.Assert.areSame("2005-06", rfc.substring(0, 7));
    
    }
  }));
  
  suite.add(new Y.Test.Case({
    name: "HREF and URI parsing",

    _should: {
      ignore: {
		"test qualify HREF": true
      }
    },
    
    "test qualify HREF": function() {
    
      /*
       * Will not always be run as localhost.
       * If port 80 is explicitly used browsers suppress the display in the URL
       * so this is ignored. Other ports are fine, e.g. 8080 etc
       * May need ammending dependent on the path, but that replicated the fnctionality in the test.
       * 
       * TODO this does not run properly in env.js with the file: protocol
       */
      var server = document.location.protocol + "//" + document.location.hostname;
      if (document.location.port && document.location.port !== '80') {
        server += ":" + document.location.port;
      }
      
      /*
       * Base URL expected for relative links. May not be correct if routes.rb changes.
       */
      var baseURL = "/test/unit/";
      
      var href = "/index.html";
      var uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/index.html", uri);
      
      href = "/somewhere/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/somewhere/index.html", uri);
      
      href = "/somewhere/else/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/somewhere/else/index.html", uri);
      
      href = "index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + baseURL + "index.html", uri);
      
      href = "somewhere/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + baseURL + "somewhere/index.html", uri);
      
      href = "somewhere/else/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + baseURL + "somewhere/else/index.html", uri);
      
      href = "./index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + baseURL + "index.html", uri);
      
      href = "../index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/test/index.html", uri);
      
      href = "../../index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/index.html", uri);
      
      href = "../somewhere/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/test/somewhere/index.html", uri);
      
      href = "../somewhere/else/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/test/somewhere/else/index.html", uri);
      
      href = "../../somewhere/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/somewhere/index.html", uri);
      
      href = "../../somewhere/else/index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + "/somewhere/else/index.html", uri);
      
      href = "somewhere/else/../../index.html";
      uri = $.qualifyHREF(href);
      Y.Assert.areSame(server + baseURL + "somewhere/else/../../index.html", uri);
      
    }
  
  }));
// ]]>
</script>
